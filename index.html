<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Media Tracker</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0f1115;
      --surface: #181b22;
      --surface-2: #1f2330;
      --text: #f3f4f6;
      --muted: #a3a8b8;
      --primary: #7dd3fc;
      --accent: #a78bfa;
      --success: #34d399;
      --warning: #fbbf24;
      --danger: #f87171;
      --border: #2a2f3b;
      --shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
      --radius: 16px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Inter", "Segoe UI", system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.6;
    }

    header {
      padding: 28px clamp(16px, 4vw, 48px);
      background: linear-gradient(135deg, rgba(125, 211, 252, 0.2), rgba(167, 139, 250, 0.2));
      border-bottom: 1px solid var(--border);
    }

    header h1 {
      margin: 0 0 8px;
      font-size: clamp(28px, 4vw, 40px);
      letter-spacing: 0.5px;
    }

    header p {
      margin: 0;
      color: var(--muted);
    }

    .app {
      padding: 24px clamp(16px, 4vw, 48px) 48px;
      display: grid;
      gap: 24px;
    }

    .tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
    }

    .tab-button {
      border: 1px solid var(--border);
      background: var(--surface);
      color: var(--text);
      padding: 10px 18px;
      border-radius: 999px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .tab-button.active {
      background: var(--primary);
      color: #0b1120;
      border-color: transparent;
      box-shadow: var(--shadow);
    }

    .card {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 20px;
      box-shadow: var(--shadow);
      border: 1px solid var(--border);
    }

    .card h2,
    .card h3 {
      margin-top: 0;
    }

    .grid {
      display: grid;
      gap: 16px;
    }

    .grid.two {
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    }

    .grid.three {
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    }

    label {
      font-size: 0.85rem;
      color: var(--muted);
      display: block;
      margin-bottom: 6px;
    }

    input,
    select,
    textarea {
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--surface-2);
      color: var(--text);
    }

    textarea {
      min-height: 90px;
      resize: vertical;
    }

    input[readonly],
    textarea[readonly] {
      color: var(--muted);
      background: rgba(31, 35, 48, 0.5);
      cursor: not-allowed;
    }

    .helper-text {
      display: block;
      margin-top: 4px;
      font-size: 0.75rem;
      color: var(--muted);
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 12px;
    }

    button.primary {
      background: var(--accent);
      color: #120b24;
      border: none;
      padding: 10px 16px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
    }

    button.ghost {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text);
      padding: 10px 16px;
      border-radius: 12px;
      cursor: pointer;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 6px 12px;
      border-radius: 999px;
      background: var(--surface-2);
      color: var(--muted);
      border: 1px solid var(--border);
      font-size: 0.8rem;
      text-align: center;
    }

    .media-list {
      display: grid;
      gap: 16px;
    }

    .media-item {
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px;
      background: rgba(31, 35, 48, 0.7);
      display: grid;
      gap: 12px;
    }

    /* Compact grid sizing keeps cards tight and consistent across sections. */
    .media-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    }

    /* Keep book list cards fixed-width so partially filled rows don't stretch. */
    .media-grid.book-grid {
      grid-template-columns: repeat(auto-fill, 180px);
      justify-content: start;
    }

    /* Compact card layout: tighter padding, smaller gaps, and readable typography. */
    .media-compact-card {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      background: rgba(31, 35, 48, 0.7);
      display: grid;
      gap: 8px;
    }

    .media-compact-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .media-compact-header h4 {
      margin: 0;
      font-size: 0.95rem;
      line-height: 1.3;
    }

    /* Keep media previews compact within cards so they don't overwhelm the layout. */
    /* Center cover artwork and preserve the full image without cropping. */
    .media-cover {
      width: min(140px, 100%);
      aspect-ratio: 3 / 4;
      border-radius: 10px;
      background: var(--surface-2);
      border: 1px solid var(--border);
      justify-self: center;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .media-cover img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      object-position: center;
      display: block;
    }

    .media-header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .media-header h4 {
      margin: 0;
    }

    .progress {
      height: 6px;
      background: var(--surface-2);
      border-radius: 999px;
      overflow: hidden;
    }

    .progress > span {
      display: block;
      height: 100%;
      background: var(--success);
      width: 0;
    }

    /* Combined progress bar and label for a single compact footprint. */
    .progress-pill {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      height: 28px;
      padding: 0 12px;
      border-radius: 999px;
      background: var(--surface-2);
      border: 1px solid var(--border);
      overflow: hidden;
      font-size: 0.78rem;
      color: var(--text);
    }

    .progress-pill .progress-fill {
      position: absolute;
      inset: 0;
      width: 0;
      background: var(--success);
      transition: width 0.2s ease;
    }

    .progress-pill .progress-label {
      position: relative;
      z-index: 1;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);
    }

    .dashboard-grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    }

    /* Compact card content styles for summaries, pills, and action buttons. */
    .media-compact-card p {
      margin: 0;
      font-size: 0.85rem;
      line-height: 1.4;
      color: var(--muted);
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .media-compact-card .pill {
      padding: 4px 10px;
      font-size: 0.72rem;
    }

    .media-compact-card .button-row {
      gap: 8px;
      margin-top: 6px;
    }

    .media-compact-card .button-row .ghost {
      padding: 6px 10px;
      font-size: 0.8rem;
    }

    .section-header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .empty {
      color: var(--muted);
      font-style: italic;
    }

    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 17, 21, 0.75);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }

    .modal-overlay.open {
      opacity: 1;
      pointer-events: auto;
    }

    .modal {
      width: min(960px, 100%);
      max-height: 90vh;
      overflow: auto;
      background: var(--surface);
      border-radius: 20px;
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      padding: 24px;
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 16px;
    }

    .modal-header h3 {
      margin: 0;
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      margin-top: 16px;
    }

    .book-format-fields {
      background: rgba(31, 35, 48, 0.6);
      border-radius: 12px;
      padding: 12px;
      border: 1px solid var(--border);
    }

    .footer {
      text-align: center;
      color: var(--muted);
      font-size: 0.85rem;
    }

    @media (max-width: 720px) {
      header {
        padding-bottom: 20px;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Media Tracker</h1>
    <p>Track your reading, watching, playing, and viewing journey with a sleek dashboard.</p>
  </header>

  <main class="app">
    <section class="card" aria-label="navigation">
      <div class="tabs" id="tabs"></div>
      <div class="button-row">
        <span class="pill" id="save-status">Auto-save active (every 30s)</span>
      </div>
    </section>

    <section class="card" id="dashboard">
      <h2>Dashboard</h2>
      <div class="dashboard-grid">
        <div class="card" id="in-progress">
          <h3>Currently in progress</h3>
          <div id="in-progress-list" class="media-grid"></div>
        </div>
        <div class="card" id="monthly-overview">
          <h3>Monthly completion overview</h3>
          <div id="monthly-list" class="media-grid"></div>
        </div>
        <div class="card" id="genre-mix">
          <h3>Current genre mix</h3>
          <div id="genre-list" class="media-grid"></div>
        </div>
      </div>
    </section>

    <section class="card" id="sections"></section>
  </main>

  <div class="modal-overlay" id="modal-overlay" aria-hidden="true" aria-label="Add new media">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modal-header">
        <h3 id="modal-title">Add new</h3>
        <button type="button" class="ghost" id="modal-close">Close</button>
      </div>
      <div id="modal-body"></div>
    </div>
  </div>

  <footer class="footer">
    Built with local browser storage. Your data stays on this device.
  </footer>

  <script>
    // -----------------------------
    // Data definitions and helpers
    // -----------------------------
    const MEDIA_TYPES = [
      {
        id: "book",
        label: "Books",
        statusLabels: {
          finished: "Finished Reading",
          current: "Currently Reading",
          wish: "Want to Read",
        },
        lengthHint: "Pages / HH:MM",
      },
      {
        id: "film",
        label: "Films",
        statusLabels: {
          finished: "Finished Watching",
          current: "Currently Watching",
          wish: "Want to Watch",
        },
        lengthHint: "Hours/Minutes",
      },
      {
        id: "tv",
        label: "TV Series",
        statusLabels: {
          finished: "Finished Watching",
          current: "Currently Watching",
          wish: "Want to Watch",
        },
        lengthHint: "Seasons/Episodes",
      },
      {
        id: "play",
        label: "Plays",
        statusLabels: {
          finished: "Finished Seeing",
          current: "Currently Seeing",
          wish: "Want to See",
        },
        lengthHint: "Acts/Minutes",
      },
      {
        id: "game",
        label: "Games",
        statusLabels: {
          finished: "Finished Playing",
          current: "Currently Playing",
          wish: "Want to Play",
        },
        lengthHint: "Hours/Levels",
      },
      {
        id: "online",
        label: "Online Videos",
        statusLabels: {
          finished: "Finished Watching",
          current: "Currently Watching",
          wish: "Want to Watch",
        },
        lengthHint: "Minutes",
      },
    ];

    const STORAGE_KEY = "media-tracker-state";
    const AUTO_SAVE_INTERVAL_MS = 30000;

    // Default empty state for all media types.
    const initialState = MEDIA_TYPES.reduce((acc, type) => {
      acc[type.id] = [];
      return acc;
    }, {});

    let state = loadState();
    let activeTab = "dashboard";

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (raw) {
          return JSON.parse(raw);
        }
      } catch (error) {
        console.warn("Failed to load saved state", error);
      }
      return structuredClone(initialState);
    }

    function saveState() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        updateSaveStatus();
      } catch (error) {
        console.warn("Failed to save state", error);
      }
    }

    function updateSaveStatus() {
      const saveStatus = document.getElementById("save-status");
      const now = new Date();
      saveStatus.textContent = `Last saved ${now.toLocaleTimeString()}`;
    }

    function formatDate(dateValue) {
      if (!dateValue) return "Not set";
      return new Date(dateValue).toLocaleDateString();
    }

    function getTodayDateString() {
      // Use a local date-only string to align with date input expectations.
      const now = new Date();
      const year = now.getFullYear();
      const month = String(now.getMonth() + 1).padStart(2, "0");
      const day = String(now.getDate()).padStart(2, "0");
      return `${year}-${month}-${day}`;
    }

    function applyAutomatedDates(item, { setAdded = false, setUpdated = false } = {}) {
      // Apply automated date fields based on lifecycle triggers and current values.
      const today = getTodayDateString();

      if (setAdded && !item.dateAdded) {
        item.dateAdded = today;
      }

      if (setUpdated) {
        item.dateUpdated = today;
      }

      if (item.status === "current" && !item.dateStarted) {
        item.dateStarted = today;
      }

      if (item.status === "finished" && !item.dateFinished) {
        item.dateFinished = today;
      }

      if (item.review && item.review.trim() && !item.dateReviewed) {
        item.dateReviewed = today;
      }
    }

    function calculateProgress(item, typeConfig) {
      const { total, completed } = getProgressSnapshot(item, typeConfig);
      if (!total || total <= 0) return 0;
      return Math.min(100, Math.round((completed / total) * 100));
    }

    function parseGenres(genresString) {
      return genresString
        .split(",")
        .map((genre) => genre.trim())
        .filter(Boolean);
    }

    function getTimeSinceUpdate(item) {
      const date = item.dateUpdated || item.dateAdded || item.dateStarted || item.dateFinished;
      if (!date) return Infinity;
      return Date.now() - new Date(date).getTime();
    }

    function generateId() {
      return crypto.randomUUID();
    }

    function parseTimeToMinutes(timeValue) {
      if (!timeValue) return 0;
      const [hours, minutes] = timeValue.split(":").map((part) => Number(part));
      if (Number.isNaN(hours) || Number.isNaN(minutes)) return 0;
      return hours * 60 + minutes;
    }

    function formatMinutesToTime(totalMinutes) {
      if (totalMinutes === null || totalMinutes === undefined || totalMinutes === "") return "";
      const safeMinutes = Number(totalMinutes);
      if (Number.isNaN(safeMinutes) || safeMinutes < 0) return "";
      const hours = Math.floor(safeMinutes / 60);
      const minutes = safeMinutes % 60;
      return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}`;
    }

    function getProgressSnapshot(item, typeConfig) {
      // Derive consistent progress metrics across media types, including book formats.
      if (typeConfig?.id === "book") {
        const format = item.bookFormat || "physical";
        if (format === "audio") {
          const total = parseTimeToMinutes(item.audioDuration) || Number(item.lengthTotal || 0);
          const completed = parseTimeToMinutes(item.audioCompleted) || Number(item.lengthCompleted || 0);
          return { total, completed, unit: "minutes" };
        }
        const total = Number(item.pageCount || item.lengthTotal || 0);
        const completed = Number(item.pagesCompleted || item.lengthCompleted || 0);
        return { total, completed, unit: "pages" };
      }

      return {
        total: Number(item.lengthTotal || 0),
        completed: Number(item.lengthCompleted || 0),
        unit: item.lengthUnit || typeConfig?.lengthHint || "",
      };
    }

    function syncBookLengthFields(item) {
      // Keep book-specific inputs aligned with generic length data for analytics.
      const format = item.bookFormat || "physical";
      if (format === "audio") {
        item.lengthTotal = parseTimeToMinutes(item.audioDuration);
        item.lengthCompleted = parseTimeToMinutes(item.audioCompleted);
        item.lengthUnit = "minutes";
      } else {
        item.lengthTotal = Number(item.pageCount || 0);
        item.lengthCompleted = Number(item.pagesCompleted || 0);
        item.lengthUnit = "pages";
      }
    }

    // ---------------------------------
    // UI rendering helpers
    // ---------------------------------
    function renderTabs() {
      const tabs = document.getElementById("tabs");
      tabs.innerHTML = "";

      const dashboardButton = createTabButton("Dashboard", "dashboard");
      tabs.appendChild(dashboardButton);

      MEDIA_TYPES.forEach((type) => {
        tabs.appendChild(createTabButton(type.label, type.id));
      });
    }

    function createTabButton(label, id) {
      const button = document.createElement("button");
      button.className = `tab-button ${activeTab === id ? "active" : ""}`;
      button.type = "button";
      button.textContent = label;
      button.addEventListener("click", () => {
        activeTab = id;
        renderApp();
      });
      return button;
    }

    function toggleDashboardVisibility() {
      // Only surface the dashboard content when the dashboard tab is active.
      const dashboard = document.getElementById("dashboard");
      if (!dashboard) return;
      dashboard.style.display = activeTab === "dashboard" ? "block" : "none";
    }

    function openModal(typeConfig) {
      const modalOverlay = document.getElementById("modal-overlay");
      if (!modalOverlay) return;
      renderModal(typeConfig);
      modalOverlay.classList.add("open");
      modalOverlay.setAttribute("aria-hidden", "false");
    }

    function closeModal() {
      const modalOverlay = document.getElementById("modal-overlay");
      const modalBody = document.getElementById("modal-body");
      if (!modalOverlay) return;
      modalOverlay.classList.remove("open");
      modalOverlay.setAttribute("aria-hidden", "true");
      if (modalBody) {
        modalBody.innerHTML = "";
      }
    }

    function renderModal(typeConfig) {
      const modalTitle = document.getElementById("modal-title");
      const modalBody = document.getElementById("modal-body");
      if (!modalTitle || !modalBody) return;

      modalTitle.textContent = `Add new ${typeConfig.label.slice(0, -1)}`;
      modalBody.innerHTML = renderForm(typeConfig);
      wireFormEvents(typeConfig);
      wireBookFormatToggles(modalBody);
    }

    function wireBookFormatToggles(rootElement) {
      if (!rootElement) return;
      const formatSelect = rootElement.querySelector("[data-field='bookFormat'], select[name='bookFormat']");
      if (!formatSelect) return;

      const updateVisibility = () => {
        const formatValue = formatSelect.value || "physical";
        rootElement.querySelectorAll("[data-format]").forEach((group) => {
          group.style.display = group.getAttribute("data-format") === formatValue ? "block" : "none";
        });
      };

      formatSelect.addEventListener("change", updateVisibility);
      updateVisibility();
    }

    function getCoverMarkup(coverUrl, title) {
      // Render cover art markup when a valid cover URL is present.
      if (!coverUrl) return "";
      const safeTitle = title || "Untitled";
      return `
        <div class="media-cover">
          <img src="${coverUrl}" alt="Cover art for ${safeTitle}" loading="lazy" />
        </div>
      `;
    }

    function renderDashboard() {
      renderInProgress();
      renderMonthlyOverview();
      renderGenreMix();
    }

    function renderInProgress() {
      const container = document.getElementById("in-progress-list");
      const inProgressItems = MEDIA_TYPES.flatMap((type) =>
        state[type.id]
          .filter((item) => item.status === "current")
          .map((item) => ({ ...item, typeLabel: type.label, typeId: type.id }))
      ).sort((a, b) => getTimeSinceUpdate(b) - getTimeSinceUpdate(a));

      container.innerHTML = "";

      if (inProgressItems.length === 0) {
        container.innerHTML = '<p class="empty">No media currently in progress.</p>';
        return;
      }

      inProgressItems.forEach((item) => {
        const typeConfig = MEDIA_TYPES.find((type) => type.id === item.typeId);
        const progress = calculateProgress(item, typeConfig);
        const card = document.createElement("div");
        card.className = "media-compact-card";
        card.innerHTML = `
          ${getCoverMarkup(item.cover, item.name)}
          <div class="media-compact-header">
            <h4>${item.name || "Untitled"}</h4>
            <span class="pill">${item.typeLabel}</span>
          </div>
          <p>${item.summary || "No summary yet."}</p>
          <div class="progress-pill">
            <span class="progress-fill" style="width:${progress}%"></span>
            <span class="progress-label">${progress}% complete</span>
          </div>
          <div class="pill">Last update: ${formatDate(item.dateUpdated)}</div>
        `;
        container.appendChild(card);
      });
    }

    function renderMonthlyOverview() {
      const container = document.getElementById("monthly-list");
      const monthlyTotals = {};

      MEDIA_TYPES.forEach((type) => {
        state[type.id]
          .filter((item) => item.status === "finished" && item.dateFinished)
          .forEach((item) => {
            const date = new Date(item.dateFinished);
            const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}`;
            monthlyTotals[key] ??= {};
            const snapshot = getProgressSnapshot(item, type);
            if (!snapshot.completed) return;
            const unit = snapshot.unit || type.lengthHint;
            monthlyTotals[key][unit] = (monthlyTotals[key][unit] || 0) + snapshot.completed;
          });
      });

      const entries = Object.entries(monthlyTotals).sort((a, b) => (a[0] < b[0] ? 1 : -1));
      container.innerHTML = "";

      if (entries.length === 0) {
        container.innerHTML = '<p class="empty">Finish items to see monthly totals.</p>';
        return;
      }

      entries.forEach(([month, totals]) => {
        const card = document.createElement("div");
        card.className = "media-compact-card";
        const totalText = Object.entries(totals)
          .map(([unit, value]) => `${value} ${unit}`)
          .join(", ");
        card.innerHTML = `
          <div class="media-header">
            <h4>${month}</h4>
          </div>
          <p>${totalText}</p>
        `;
        container.appendChild(card);
      });
    }

    function renderGenreMix() {
      const container = document.getElementById("genre-list");
      const genreCounts = {};

      MEDIA_TYPES.forEach((type) => {
        state[type.id].forEach((item) => {
          parseGenres(item.genres || "").forEach((genre) => {
            genreCounts[genre] = (genreCounts[genre] || 0) + 1;
          });
        });
      });

      const entries = Object.entries(genreCounts).sort((a, b) => b[1] - a[1]);
      container.innerHTML = "";

      if (entries.length === 0) {
        container.innerHTML = '<p class="empty">Add genres to see your mix.</p>';
        return;
      }

      entries.slice(0, 12).forEach(([genre, count]) => {
        const card = document.createElement("div");
        card.className = "media-compact-card";
        card.innerHTML = `
          <div class="media-header">
            <h4>${genre}</h4>
            <span class="pill">${count} items</span>
          </div>
        `;
        container.appendChild(card);
      });
    }

    function renderSections() {
      const container = document.getElementById("sections");

      if (activeTab === "dashboard") {
        container.innerHTML = "";
        return;
      }

      const typeConfig = MEDIA_TYPES.find((type) => type.id === activeTab);
      if (!typeConfig) return;

      container.innerHTML = `
        <div class="section-header">
          <div>
            <h2>${typeConfig.label}</h2>
            <p class="pill">Suggested length unit: ${typeConfig.lengthHint}</p>
          </div>
          <button type="button" class="primary" id="add-new-button">Add new</button>
        </div>
        <div class="card">
          <h3>${typeConfig.label} list</h3>
          <div class="media-grid ${typeConfig.id === "book" ? "book-grid" : ""}" id="list-${typeConfig.id}"></div>
        </div>
      `;

      const addButton = document.getElementById("add-new-button");
      if (addButton) {
        addButton.addEventListener("click", () => openModal(typeConfig));
      }
      renderMediaList(typeConfig);
    }

    function renderForm(typeConfig) {
      // Render the form HTML for adding new items inside the modal.
      const isBook = typeConfig.id === "book";
      return `
        <form id="form-${typeConfig.id}" class="grid two">
          <div>
            <label for="${typeConfig.id}-name">Name</label>
            <input id="${typeConfig.id}-name" name="name" placeholder="Title" required />
          </div>
          <div>
            <label for="${typeConfig.id}-status">Status</label>
            <select id="${typeConfig.id}-status" name="status">
              <option value="finished">${typeConfig.statusLabels.finished}</option>
              <option value="current">${typeConfig.statusLabels.current}</option>
              <option value="wish">${typeConfig.statusLabels.wish}</option>
            </select>
          </div>
          <div>
            <label for="${typeConfig.id}-summary">Summary</label>
            <textarea id="${typeConfig.id}-summary" name="summary" placeholder="Short synopsis"></textarea>
          </div>
          <div>
            <label for="${typeConfig.id}-cover">Photo / Poster / Cover</label>
            <input id="${typeConfig.id}-cover" name="cover" placeholder="Image URL" />
          </div>
          ${isBook ? `
          <div>
            <label for="${typeConfig.id}-bookFormat">Book format</label>
            <select id="${typeConfig.id}-bookFormat" name="bookFormat">
              <option value="physical">Physical book (pages)</option>
              <option value="audio">Audio book (HH:MM)</option>
            </select>
          </div>
          <div class="book-format-fields" data-format="physical">
            <label for="${typeConfig.id}-pageCount">Page count</label>
            <input id="${typeConfig.id}-pageCount" name="pageCount" type="number" min="0" />
          </div>
          <div class="book-format-fields" data-format="physical">
            <label for="${typeConfig.id}-pagesCompleted">Pages completed</label>
            <input id="${typeConfig.id}-pagesCompleted" name="pagesCompleted" type="number" min="0" />
          </div>
          <div class="book-format-fields" data-format="audio">
            <label for="${typeConfig.id}-audioDuration">Audio duration (HH:MM)</label>
            <input id="${typeConfig.id}-audioDuration" name="audioDuration" type="time" step="60" />
          </div>
          <div class="book-format-fields" data-format="audio">
            <label for="${typeConfig.id}-audioCompleted">Audio completed (HH:MM)</label>
            <input id="${typeConfig.id}-audioCompleted" name="audioCompleted" type="time" step="60" />
          </div>
          <input type="hidden" name="lengthTotal" />
          <input type="hidden" name="lengthCompleted" />
          <input type="hidden" name="lengthUnit" />
          ` : `
          <div>
            <label for="${typeConfig.id}-length-total">Total length (${typeConfig.lengthHint})</label>
            <input id="${typeConfig.id}-length-total" name="lengthTotal" type="number" min="0" />
          </div>
          <div>
            <label for="${typeConfig.id}-length-completed">Completed length</label>
            <input id="${typeConfig.id}-length-completed" name="lengthCompleted" type="number" min="0" />
          </div>
          <div>
            <label for="${typeConfig.id}-length-unit">Length unit</label>
            <input id="${typeConfig.id}-length-unit" name="lengthUnit" placeholder="pages, hours, episodes" />
          </div>
          `}
          <div>
            <label for="${typeConfig.id}-rating">Rating (0-5)</label>
            <input id="${typeConfig.id}-rating" name="rating" type="number" min="0" max="5" step="0.5" />
          </div>
          <div>
            <label for="${typeConfig.id}-genres">Genres</label>
            <input id="${typeConfig.id}-genres" name="genres" placeholder="Comma-separated" />
          </div>
          <div>
            <label for="${typeConfig.id}-contributors">Authors / Directors / Actors</label>
            <input id="${typeConfig.id}-contributors" name="contributors" placeholder="People involved" />
          </div>
          <div>
            <label for="${typeConfig.id}-notes">Personal notes</label>
            <textarea id="${typeConfig.id}-notes" name="notes"></textarea>
          </div>
          <div>
            <label for="${typeConfig.id}-review">Personal review</label>
            <textarea id="${typeConfig.id}-review" name="review"></textarea>
          </div>
          <div>
            <label for="${typeConfig.id}-date-published">Publication / Production date</label>
            <input id="${typeConfig.id}-date-published" name="datePublished" type="date" />
          </div>
          <div class="modal-actions" style="grid-column: 1 / -1;">
            <button type="submit" class="primary">Add ${typeConfig.label.slice(0, -1)}</button>
            <button type="button" class="ghost" id="modal-cancel">Cancel</button>
          </div>
        </form>
      `;
    }

    function renderEditForm(typeConfig, item) {
      // Render a fully detailed edit form with automated dates surfaced as read-only fields.
      const isBook = typeConfig.id === "book";
      const bookFormat = item.bookFormat || "physical";
      const audioDuration = item.audioDuration || formatMinutesToTime(item.lengthTotal || 0);
      const audioCompleted = item.audioCompleted || formatMinutesToTime(item.lengthCompleted || 0);

      return `
        <form id="edit-form-${typeConfig.id}" class="grid two">
          <input type="hidden" name="id" value="${item.id}" />
          <div>
            <label for="edit-${typeConfig.id}-name">Name</label>
            <input id="edit-${typeConfig.id}-name" name="name" value="${item.name || ""}" required />
          </div>
          <div>
            <label for="edit-${typeConfig.id}-status">Status</label>
            <select id="edit-${typeConfig.id}-status" name="status">
              <option value="finished" ${item.status === "finished" ? "selected" : ""}>${typeConfig.statusLabels.finished}</option>
              <option value="current" ${item.status === "current" ? "selected" : ""}>${typeConfig.statusLabels.current}</option>
              <option value="wish" ${!item.status || item.status === "wish" ? "selected" : ""}>${typeConfig.statusLabels.wish}</option>
            </select>
          </div>
          <div>
            <label for="edit-${typeConfig.id}-summary">Summary</label>
            <textarea id="edit-${typeConfig.id}-summary" name="summary">${item.summary || ""}</textarea>
          </div>
          <div>
            <label for="edit-${typeConfig.id}-cover">Photo / Poster / Cover</label>
            <input id="edit-${typeConfig.id}-cover" name="cover" value="${item.cover || ""}" />
          </div>
          ${isBook ? `
          <div>
            <label for="edit-${typeConfig.id}-bookFormat">Book format</label>
            <select id="edit-${typeConfig.id}-bookFormat" name="bookFormat">
              <option value="physical" ${bookFormat === "physical" ? "selected" : ""}>Physical book (pages)</option>
              <option value="audio" ${bookFormat === "audio" ? "selected" : ""}>Audio book (HH:MM)</option>
            </select>
          </div>
          <div class="book-format-fields" data-format="physical">
            <label for="edit-${typeConfig.id}-pageCount">Page count</label>
            <input id="edit-${typeConfig.id}-pageCount" name="pageCount" type="number" min="0" value="${item.pageCount || item.lengthTotal || ""}" />
          </div>
          <div class="book-format-fields" data-format="physical">
            <label for="edit-${typeConfig.id}-pagesCompleted">Pages completed</label>
            <input id="edit-${typeConfig.id}-pagesCompleted" name="pagesCompleted" type="number" min="0" value="${item.pagesCompleted || item.lengthCompleted || ""}" />
          </div>
          <div class="book-format-fields" data-format="audio">
            <label for="edit-${typeConfig.id}-audioDuration">Audio duration (HH:MM)</label>
            <input id="edit-${typeConfig.id}-audioDuration" name="audioDuration" type="time" step="60" value="${audioDuration}" />
          </div>
          <div class="book-format-fields" data-format="audio">
            <label for="edit-${typeConfig.id}-audioCompleted">Audio completed (HH:MM)</label>
            <input id="edit-${typeConfig.id}-audioCompleted" name="audioCompleted" type="time" step="60" value="${audioCompleted}" />
          </div>
          <input type="hidden" name="lengthTotal" />
          <input type="hidden" name="lengthCompleted" />
          <input type="hidden" name="lengthUnit" />
          ` : `
          <div>
            <label for="edit-${typeConfig.id}-length-total">Total length (${typeConfig.lengthHint})</label>
            <input id="edit-${typeConfig.id}-length-total" name="lengthTotal" type="number" min="0" value="${item.lengthTotal || ""}" />
          </div>
          <div>
            <label for="edit-${typeConfig.id}-length-completed">Completed length</label>
            <input id="edit-${typeConfig.id}-length-completed" name="lengthCompleted" type="number" min="0" value="${item.lengthCompleted || ""}" />
          </div>
          <div>
            <label for="edit-${typeConfig.id}-length-unit">Length unit</label>
            <input id="edit-${typeConfig.id}-length-unit" name="lengthUnit" value="${item.lengthUnit || ""}" />
          </div>
          `}
          <div>
            <label for="edit-${typeConfig.id}-rating">Rating (0-5)</label>
            <input id="edit-${typeConfig.id}-rating" name="rating" type="number" min="0" max="5" step="0.5" value="${item.rating || ""}" />
          </div>
          <div>
            <label for="edit-${typeConfig.id}-genres">Genres</label>
            <input id="edit-${typeConfig.id}-genres" name="genres" value="${item.genres || ""}" />
          </div>
          <div>
            <label for="edit-${typeConfig.id}-contributors">Authors / Directors / Actors</label>
            <input id="edit-${typeConfig.id}-contributors" name="contributors" value="${item.contributors || ""}" />
          </div>
          <div>
            <label for="edit-${typeConfig.id}-notes">Personal notes</label>
            <textarea id="edit-${typeConfig.id}-notes" name="notes">${item.notes || ""}</textarea>
          </div>
          <div>
            <label for="edit-${typeConfig.id}-review">Personal review</label>
            <textarea id="edit-${typeConfig.id}-review" name="review">${item.review || ""}</textarea>
          </div>
          <div>
            <label for="edit-${typeConfig.id}-date-added">Date added</label>
            <input id="edit-${typeConfig.id}-date-added" name="dateAdded" type="date" value="${item.dateAdded || ""}" readonly />
            <span class="helper-text">Auto-set when the entry is created.</span>
          </div>
          <div>
            <label for="edit-${typeConfig.id}-date-started">Date started</label>
            <input id="edit-${typeConfig.id}-date-started" name="dateStarted" type="date" value="${item.dateStarted || ""}" readonly />
            <span class="helper-text">Auto-set when status changes to in progress.</span>
          </div>
          <div>
            <label for="edit-${typeConfig.id}-date-finished">Date finished</label>
            <input id="edit-${typeConfig.id}-date-finished" name="dateFinished" type="date" value="${item.dateFinished || ""}" readonly />
            <span class="helper-text">Auto-set when status changes to completed.</span>
          </div>
          <div>
            <label for="edit-${typeConfig.id}-date-reviewed">Date reviewed</label>
            <input id="edit-${typeConfig.id}-date-reviewed" name="dateReviewed" type="date" value="${item.dateReviewed || ""}" readonly />
            <span class="helper-text">Auto-set when a review is added.</span>
          </div>
          <div>
            <label for="edit-${typeConfig.id}-date-updated">Date updated</label>
            <input id="edit-${typeConfig.id}-date-updated" name="dateUpdated" type="date" value="${item.dateUpdated || ""}" readonly />
            <span class="helper-text">Auto-set whenever details change.</span>
          </div>
          <div>
            <label for="edit-${typeConfig.id}-date-published">Publication / Production date</label>
            <input id="edit-${typeConfig.id}-date-published" name="datePublished" type="date" value="${item.datePublished || ""}" />
          </div>
          <div class="modal-actions" style="grid-column: 1 / -1;">
            <button type="submit" class="primary">Save changes</button>
            <button type="button" class="ghost" id="modal-cancel">Cancel</button>
          </div>
        </form>
      `;
    }

    function renderProgressUpdateForm(typeConfig, item) {
      // Render a minimal modal form that only updates the completed progress field.
      const isBook = typeConfig.id === "book";
      const bookFormat = item.bookFormat || "physical";
      let inputId = `progress-${typeConfig.id}-completed`;
      let labelText = `Completed ${typeConfig.lengthHint}`;
      let inputType = "number";
      let inputValue = item.lengthCompleted || "";
      let inputStep = "1";

      if (isBook && bookFormat === "audio") {
        inputId = `progress-${typeConfig.id}-audio-completed`;
        labelText = "Audio completed (HH:MM)";
        inputType = "time";
        inputValue = item.audioCompleted || formatMinutesToTime(item.lengthCompleted || 0);
        inputStep = "60";
      } else if (isBook) {
        inputId = `progress-${typeConfig.id}-pages-completed`;
        labelText = "Pages completed";
        inputType = "number";
        inputValue = item.pagesCompleted || item.lengthCompleted || "";
      }

      return `
        <form id="progress-form-${typeConfig.id}" class="grid">
          <input type="hidden" name="id" value="${item.id}" />
          <div>
            <label for="${inputId}">${labelText}</label>
            <input
              id="${inputId}"
              name="lengthCompleted"
              type="${inputType}"
              value="${inputValue}"
              step="${inputStep}"
              min="0"
              required
            />
            <span class="helper-text">Update the completed progress value only.</span>
          </div>
          <div class="modal-actions" style="grid-column: 1 / -1;">
            <button type="submit" class="primary">Update progress</button>
            <button type="button" class="ghost" id="modal-cancel">Cancel</button>
          </div>
        </form>
      `;
    }

    function openProgressModal(typeConfig, item) {
      // Open a simplified modal for updating only the completed progress field.
      const modalOverlay = document.getElementById("modal-overlay");
      if (!modalOverlay) return;
      const modalTitle = document.getElementById("modal-title");
      const modalBody = document.getElementById("modal-body");
      if (!modalTitle || !modalBody) return;

      modalTitle.textContent = `Update progress Â· ${item.name || typeConfig.label.slice(0, -1)}`;
      modalBody.innerHTML = renderProgressUpdateForm(typeConfig, item);
      wireProgressFormEvents(typeConfig, item.id);
      modalOverlay.classList.add("open");
      modalOverlay.setAttribute("aria-hidden", "false");
    }

    function wireProgressFormEvents(typeConfig, itemId) {
      // Persist a targeted progress update without touching other fields.
      const form = document.getElementById(`progress-form-${typeConfig.id}`);
      if (!form) return;

      const cancelButton = document.getElementById("modal-cancel");
      if (cancelButton) {
        cancelButton.addEventListener("click", () => closeModal());
      }

      form.addEventListener("submit", (event) => {
        event.preventDefault();
        const formData = new FormData(form);
        const updatedValue = formData.get("lengthCompleted");
        const item = state[typeConfig.id].find((entry) => entry.id === itemId);
        if (!item) return;

        if (typeConfig.id === "book") {
          const bookFormat = item.bookFormat || "physical";
          if (bookFormat === "audio") {
            item.audioCompleted = updatedValue;
          } else {
            item.pagesCompleted = updatedValue;
          }
          syncBookLengthFields(item);
        } else {
          item.lengthCompleted = updatedValue;
        }

        applyAutomatedDates(item, { setUpdated: true });
        saveState();
        closeModal();
        renderApp();
      });
    }

    function openEditModal(typeConfig, item) {
      // Open the shared modal with a pre-filled edit form for the selected entry.
      const modalOverlay = document.getElementById("modal-overlay");
      if (!modalOverlay) return;
      const modalTitle = document.getElementById("modal-title");
      const modalBody = document.getElementById("modal-body");
      if (!modalTitle || !modalBody) return;

      modalTitle.textContent = `Edit ${item.name || typeConfig.label.slice(0, -1)}`;
      modalBody.innerHTML = renderEditForm(typeConfig, item);
      wireEditFormEvents(typeConfig, item.id);
      wireBookFormatToggles(modalBody);
      modalOverlay.classList.add("open");
      modalOverlay.setAttribute("aria-hidden", "false");
    }

    function wireEditFormEvents(typeConfig, itemId) {
      // Persist edits to the selected item while keeping automated dates in sync.
      const form = document.getElementById(`edit-form-${typeConfig.id}`);
      if (!form) return;

      const cancelButton = document.getElementById("modal-cancel");
      if (cancelButton) {
        cancelButton.addEventListener("click", () => closeModal());
      }

      form.addEventListener("submit", (event) => {
        event.preventDefault();
        const formData = new FormData(form);
        const updatedValues = Object.fromEntries(formData.entries());
        const item = state[typeConfig.id].find((entry) => entry.id === itemId);
        if (!item) return;

        Object.assign(item, updatedValues);
        if (typeConfig.id === "book") {
          syncBookLengthFields(item);
        }
        applyAutomatedDates(item, { setUpdated: true });
        saveState();
        closeModal();
        renderApp();
      });
    }

    function wireFormEvents(typeConfig) {
      const form = document.getElementById(`form-${typeConfig.id}`);
      if (!form) return;

      const cancelButton = document.getElementById("modal-cancel");
      if (cancelButton) {
        cancelButton.addEventListener("click", () => closeModal());
      }

      form.addEventListener("submit", (event) => {
        event.preventDefault();
        const formData = new FormData(form);
        const item = Object.fromEntries(formData.entries());
        item.id = generateId();
        item.createdAt = new Date().toISOString();
        applyAutomatedDates(item, { setAdded: true, setUpdated: true });
        if (typeConfig.id === "book") {
          syncBookLengthFields(item);
        }
        state[typeConfig.id].push(item);
        form.reset();
        saveState();
        closeModal();
        renderApp();
      });
    }

    function renderMediaList(typeConfig) {
      const listContainer = document.getElementById(`list-${typeConfig.id}`);
      if (!listContainer) return;

      listContainer.innerHTML = "";

      if (state[typeConfig.id].length === 0) {
        listContainer.innerHTML = '<p class="empty">No entries yet.</p>';
        return;
      }

      state[typeConfig.id].forEach((item) => {
        const progress = calculateProgress(item, typeConfig);
        const card = document.createElement("div");
        card.className = "media-compact-card";
        card.innerHTML = `
          ${getCoverMarkup(item.cover, item.name)}
          <div class="media-compact-header">
            <h4>${item.name || "Untitled"}</h4>
            <span class="pill">${typeConfig.statusLabels[item.status] || typeConfig.statusLabels.wish}</span>
          </div>
          <p>${item.summary || "No summary yet."}</p>
          <div class="progress-pill">
            <span class="progress-fill" style="width:${progress}%"></span>
            <span class="progress-label">${progress}% complete</span>
          </div>
          <div class="button-row">
            <button class="ghost" data-action="edit" data-id="${item.id}">View / Edit</button>
            <button class="ghost" data-action="update-progress" data-id="${item.id}">Update progress</button>
            <button class="ghost" data-action="delete" data-id="${item.id}">Delete</button>
          </div>
        `;
        listContainer.appendChild(card);
      });

      listContainer.addEventListener("click", handleListClick);
    }

    function handleListClick(event) {
      const target = event.target;
      if (!(target instanceof HTMLElement)) return;

      const id = target.getAttribute("data-id");
      if (!id) return;
      const action = target.getAttribute("data-action");

      const typeId = activeTab;
      if (action === "edit") {
        const item = state[typeId].find((entry) => entry.id === id);
        const typeConfig = MEDIA_TYPES.find((type) => type.id === typeId);
        if (item && typeConfig) {
          openEditModal(typeConfig, item);
        }
        return;
      }

      if (action === "update-progress") {
        const item = state[typeId].find((entry) => entry.id === id);
        const typeConfig = MEDIA_TYPES.find((type) => type.id === typeId);
        if (item && typeConfig) {
          openProgressModal(typeConfig, item);
        }
        return;
      }

      if (action === "delete") {
        state[typeId] = state[typeId].filter((item) => item.id !== id);
        saveState();
        renderApp();
      }
    }

    function renderApp() {
      renderTabs();
      renderDashboard();
      toggleDashboardVisibility();
      renderSections();
    }

    // Set up modal controls for accessibility.
    const modalOverlay = document.getElementById("modal-overlay");
    const modalCloseButton = document.getElementById("modal-close");
    if (modalCloseButton) {
      modalCloseButton.addEventListener("click", () => closeModal());
    }
    if (modalOverlay) {
      modalOverlay.addEventListener("click", (event) => {
        if (event.target === modalOverlay) {
          closeModal();
        }
      });
    }
    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        closeModal();
      }
    });

    // Initialize the app and set up auto-save.
    renderApp();
    setInterval(saveState, AUTO_SAVE_INTERVAL_MS);
  </script>
</body>
</html>
